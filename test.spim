	 .data
_true: .asciiz "true"
_false: .asciiz "false"
_.newline: .asciiz "\n"
.data
yeaha:  .word 0		#global static variable
.text
.globl yeaha		#global var
.data
sup:  .word 0		#global static variable
.text
.globl sup		#global var
.globl returner
		# FUNCTION ENTRY returner
returner:
	sw    $ra, 0($sp)		#PUSH
	subu  $sp, $sp, 4
	sw    $fp, 0($sp)		#PUSH
	subu  $sp, $sp, 4
	addu  $fp, $sp, 8
		#  STATEMENTS
	li    $a0, -1		#load true val 
	sw    $a0, sup		#store value of global varsup
.data
._L1:  .word 1		#Integer Literal
.text
	lw    $a0, ._L1
	sw    $a0, 0($sp)		#PUSH
	subu  $sp, $sp, 4
.data
._L2:  .word 1		#Integer Literal
.text
	lw    $a0, ._L2
	neg   $a0, $a0
	lw    $t1, 4($sp)
	mult  $a0, $t1		#multiply
	mflo  $a0
	addiu $sp, $sp, 4		#POP
	sw    $a0, 8($fp)		#store value of local vara
	lw    $a0, sup		#load variable sup
	li    $t1, -1		#load true value
	bne   $a0, $t1, ._L3		#if false jump to make it true
	li    $a0, 0		#change true to false
	j     ._L4
._L3:
	li    $a0, -1		#change false to true
._L4:
	li    $t1, -1		#Load to comapre if true
	bne   $a0, $t1, ._L5		#If Statement
		#  STATEMENTS
.data
._L6:  .asciiz "woot"		#String Literal
.text
	la    $a0, ._L6
	li    $v0, 4
	syscall
	la    $a0, _.newline
	li    $v0, 4
	syscall
._L5:		# If Statement End
.data
._L7:  .word 2		#Integer Literal
.text
	lw    $a0, ._L7
	sw    $a0, 0($sp)		#PUSH
	subu  $sp, $sp, 4
.data
._L8:  .word 1		#Integer Literal
.text
	lw    $a0, ._L8
	neg   $a0, $a0
	lw    $t1, 4($sp)
	div   $t1, $a0		#divide
	mflo  $a0
	addiu $sp, $sp, 4		#POP
	j     ._L0
._L0:		# FUNCTION EXIT
	lw    $ra, 0($fp)		#restore ra
	move  $sp, $fp		#restore SP
	lw    $fp, -4($fp)		#restore FP
	jr    $ra		#return to caller
.globl trivRec
		# FUNCTION ENTRY trivRec
trivRec:
	sw    $ra, 0($sp)		#PUSH
	subu  $sp, $sp, 4
	sw    $fp, 0($sp)		#PUSH
	subu  $sp, $sp, 4
	addu  $fp, $sp, 8
		#  STATEMENTS
	lw    $a0, 4($fp)		#load local variable k
	sw    $a0, 0($sp)		#PUSH
	subu  $sp, $sp, 4
.data
._L12:  .word 0		#Integer Literal
.text
	lw    $a0, ._L12
	lw    $t1, 4($sp)
	bgt   $t1, $a0, ._L10		#Check if greater
	li    $a0, 0		#Load false
	j     ._L11		#Jump to end, it's not greater
._L10:		# True Label, in case greater
	li    $a0, -1		#Load true
._L11:		# End of greater
	li    $t1, -1		#Load to comapre if true
	bne   $a0, $t1, ._L13		#If Statement
		#  STATEMENTS
	lw    $a0, 4($fp)		#load local variable k
	li    $v0, 1
	syscall
	la    $a0, _.newline
	li    $v0, 4
	syscall
	lw    $a0, 4($fp)		#load local variable k
	sw    $a0, 0($sp)		#PUSH
	subu  $sp, $sp, 4
.data
._L14:  .word 1		#Integer Literal
.text
	lw    $a0, ._L14
	lw    $t1, 4($sp)
	sub   $a0, $t1, $a0		#subtract
	addiu $sp, $sp, 4		#POP
	sw    $a0, 0($sp)		#PUSH
	subu  $sp, $sp, 4
	jal   trivRec		#call method
._L13:		# If Statement End
._L9:		# FUNCTION EXIT
	lw    $ra, 0($fp)		#restore ra
	move  $sp, $fp		#restore SP
	lw    $fp, -4($fp)		#restore FP
	jr    $ra		#return to caller
.globl main
		# FUNCTION ENTRY main
main:
	sw    $ra, 0($sp)		#PUSH
	subu  $sp, $sp, 4
	sw    $fp, 0($sp)		#PUSH
	subu  $sp, $sp, 4
	addu  $fp, $sp, 8
		#  STATEMENTS
.data
._L16:  .word 9		#Integer Literal
.text
	lw    $a0, ._L16
	sw    $a0, 4($fp)		#store value of local vark
.data
._L17:  .word 10		#Integer Literal
.text
	lw    $a0, ._L17
	sw    $a0, 0($sp)		#PUSH
	subu  $sp, $sp, 4
	jal   returner		#call method
	li    $v0, 1
	syscall
	la    $a0, _.newline
	li    $v0, 4
	syscall
._L15:		# FUNCTION EXIT
	lw    $ra, 0($fp)		#restore ra
	move  $sp, $fp		#restore SP
	lw    $fp, -4($fp)		#restore FP
	jr    $ra		#return to caller
